'''
리스트
'''
print(list('abc'))  # ['a', 'b', 'c']
print(list([1, 2, 3]))  # [1, 2, 3]
print(list(range(0, 7)))  # [0, 1, 2, 3, 4, 5, 6]
print(list(range(0, 7, 2)))  # [0, 2, 4, 6]

# 원소값 없이 리스트 만들기
print(list([None] * 5))

'''
튜플
'''

tu = tuple()

# 원소가 1개 일 떈 반드시 쉼표를 적어준다.
# 쉼표가 없으면 튜플이 아닌 단순변수로 취급한다.
# ex) 1 / (1)
tu = 1,
print(tu)  # (1,)

tu = 1, 2, 3  # 결합 연산자 () 생략 가능
print(tu)  # (1, 2, 3)

# 튜플은 딕셔너리의 키로 사용 가능하다.
tu = (1, 2)
a = {tu: 'a'}
print(a)

# 튜플은 값을 변경할 수 없다.
# tu[0] = 2

# 튜플은 좌변에 올 수 없다.
tu = [1, 2, 3, 4, 5]
# tu[1: 3] = tu[1: 3]
# tu[0] = tu[1]

'''
인덱스로 원소 접근하기
'''

#    0   1   2   3   4   5   6
x = [11, 22, 33, 44, 55, 66, 77]
#    -7  -6  -5  -4  -3  -2  -1

print(x[2])
print(x[-3])

x[-3] = 3.14  # int -> float로 자동 형변환이 일어난다. (파이썬은 객체 참조를 하므로 객체의 식별 변호가 변경.)
print(x[-3])

'''
슬라이스식으로 원소에 접근하기
'''

#    0   1   2   3   4   5   6
s = [11, 22, 33, 44, 55, 66, 77]
#    -7  -6  -5  -4  -3  -2  -1

print(s[:])
print(s[0:7:2])  # [11, 33, 55, 77]
print(s[-4:-2])  # [44, 55]
print(s[::2])  # [11, 33, 55, 77] 맨 앞부터 맨 뒤 원소 까지 2개씩 건너뛰며 출력
print(s[3:1])  # [] 범위가 이상해도 오류는 나지 않는다.
print(s[::-1])  # [77, 66, 55, 44, 33, 22, 11] 맨 끝 원소부터 저부 출력

'''
빈 배열 판단하기
'''

arr = []

if arr:
    print('비어있지 않음')
else:
    print('비어있음')

'''
비교 연산자로 배열의 대소 또는 등가 관계 판단
1. 어느 원소의 값이 더 크면 그 배열이 더 크다고 판단
2. 원소의 수가 다른 경우 원소 수가 더 많은 배열이 더 크다코 판단.
'''

#
print([1, 2, 3] < [1, 2, 3, 4] < [1, 2, 3, 4, 5])  # True
print([1, 2, 3, 4, 5] < [0, 0, 0, 0, 0, 0])  # False (1번 조건에서 판단)

'''
내부 표기 생성
'''

a = [1, 2, 3, 4, 5]
twise = [num * 2 for num in a if num % 2 == 1]
print(twise) # [2, 6, 10]

'''
리스트, 튜플 동일성 판단
'''

lst1 = [1, 2, 3]
lst2 = [1, 2, 3]

# lst1과 lst2의 식별변호가 같은지 연산자 is로 판단해보면 리터럴(고정된 값)이 아니므로 False가 나온다.
print(lst1 is lst2)  # False

lst2 = lst1

# 대입식으로 lst2와 lst1과 같은 실체(리스트)를 참조하게 했더니 True가 나온다.
print(lst1 is lst2)  # True

# 따라서 lst1의 원소를 바꾸면 lst2도 변경된다.
lst1[1] = 5
print(lst2) # [1, 5, 3]