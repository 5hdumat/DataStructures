'''
도수 정렬

도수 정렬은 원소의 대소 관계를 판단하지 않고 빠르게 정렬하는 알고리즘으로, 분포수 세기(distribution counting) 정렬이라고도 한다.

1. 배열 x로 도수 분포표를 만든 후
2. 누적 도수 분포표를 그린 배열 f를 만들고,
3. 서로 대조하면서 작업용 배열 b 배열에 저장하면 b 배열은 정렬된 상태가 된다.
4. b 배열을 x 배열에 복사한다.

이 정렬은 순서대로 스캔하며 대조하므로 안정적인 정렬이다.
다만 뒤에서 부터 스캔하지 않고 앞에서 부터 스캔하면 안정적이지 않은 정렬이 된다. (동일한 원소의 순서가 뒤바뀐다.)

대소관계 비교가 없고, 이중 조건문, 반복문이 없고 재귀호출이 없어 굉장히 빠른 알고리즘이지만 배열의 최솟값과 최댓값을 아는 경우에만 적용할 수 있는 알고리즘이다.
'''


def counting_sort(x, max):
    f = [0] * (max + 1)  # 누적 도수 분포표 배열
    b = [0] * n  # 작업용 배열

    # 1단계. 배열 x로 도수 분포표 그리기
    for i in range(n):
        f[x[i]] += 1

    # 2단계. 누적 도수 분포표 그리기
    for i in range(1, len(f)):
        f[i] += f[i - 1]

    # 3단계. 누적 도수 분포표와 배열 x 대조하기
    for i in range(n - 1, -1, -1):
        f[x[i]] -= 1 # f 배열에서 x[i] 값의 위치를 가져와야한다. 인덱스는 0부터 시작하므로 -1을 해주고
        b[f[x[i]]] = x[i] # b 배열에 집어넣는다.

    # 4단계. b 배열을 원본 배열에 복사
    for i in range(n):
        x[i] = b[i]

if __name__ == '__main__':
    n = int(input('원소 수를 입력해주세요: '))
    x = [None] * n

    for i in range(n):
        x[i] = int(input(f'x[{i}]: '))

    counting_sort(x, max(x))

    for i in range(n):
        print(f'x[{i}] = {x[i]}')
